# eBPF kernel programs using Aya:


## The eBPF Flow with Aya

The lifecycle of an eBPF program using Aya can be broken down into three main phases:

**Development**, **Loading**, and **Execution**.

### 1. Development Phase (The Dual-Project Structure)

When you initialize an Aya project, you typically have two distinct crates:

* **The eBPF Program (Kernel-space):** Written in Rust with `no_std`. 
  This code is compiled into an ELF file containing eBPF bytecode using the `bpf-linker`.
  
* **The Userspace Application:** A standard Rust application that uses the `aya` library to load
  the bytecode, attach it to hooks, and read data from maps.
  

### 2. The Loading & Verification Phase

Once the userspace app starts, the following sequence occurs:

1. **Loading:** The userspace app reads the compiled ELF file.
2. **Syscall:** It issues the `bpf()` system call to move the bytecode into the kernel.
3. **Verification:** The **Kernel Verifier** checks the Rust-generated bytecode for safety 
   (e.g., no infinite loops, no out-of-bounds memory access).
4. **JIT Compilation:** The kernel converts the generic eBPF bytecode into machine-specific
   instructions (x86_64, ARM, etc.) for native performance.

### 3. Execution & Data Flow

After the program is "attached" to a hook (like a network packet or a function call), the 
real-time flow looks like this:

| Component | Action |
| --- | --- |
| **Hook Point** | An event triggers (e.g., `XDP` for a packet or `Kprobe` for a kernel function). |
| **eBPF Program** | The Rust code runs in the kernel, processing the event. |
| **eBPF Maps** | The program stores data (counts, IP addresses, etc.) in a shared memory structure. |
| **Userspace** | The Aya-powered app polls the Map or listens to a `PerfEventArray` to display or act on the data. |


## Example Code Logic

### Kernel-Side (`myapp-ebpf/src/main.rs`)

This is what runs inside the kernel. Notice the `#[xdp]` macro provided by Aya.

```rust
#[xdp]
pub fn my_packet_filter(ctx: XdpContext) -> u32 {
    match try_my_packet_filter(ctx) {
        Ok(ret) => ret,
        Err(_) => xdp_action::XDP_ABORTED,
    }
}

```

### Userspace-Side (`myapp/src/main.rs`)

Aya makes loading the program feel like standard Rust.

```rust
let mut bpf = Bpf::load(include_bytes_aligned!(
    "../../target/bpfel-unknown-none/debug/myapp"
))?;

let program: &mut Xdp = bpf.program_mut("my_packet_filter").unwrap().try_into()?;
program.load()?;
program.attach(&interface, XdpFlags::default())?;

```

## Why Aya?

* **Type Safety:** 
    You can share the same `struct` definitions between userspace and the kernel, 
    preventing memory alignment bugs.
    
* **No C Dependency:** You don't need `llvm` or `clang` installed on the target machine; 
  it's a pure Rust toolchain.
  
* **Async Support:** 
    Userspace Aya works seamlessly with `tokio`, making it easy to handle high-throughput event
    streams.

--- 

# **Context** :  `ctx` :

The concept of **Context** is functionally the same across all eBPF frameworks, its a standardized gateway 
through which your program interacts with the kernel event that triggered it. 

- **Aya  (Rust)** : Provides a strong typed **`Context`** object ( like `XdpContext` )  that feels like
  native Rust structure.

- **BCC (C/Python)** : Passes a pointer to a C struct ( ex: `struct pt_regs *ctx` ) which you then
  manipulate using C-Style arithemitic or BCC helper macros.

- **bpftrace(DSL)** : Simplifies the conctext into builtin variables like `arg0`, `arg1` ...or `$skb,
  hiding the pointer logic entirely. 

### Comparison of Context Access

| Feature | **Aya (Rust)** | **BCC (C)** | **bpftrace** |
| --- | --- | --- | --- |
| **Type Safety** | High (Compile-time checked) | Medium (C-style casts) | Low (Implicitly typed) |
| **Access Method** | `ctx.data`, `ctx.data_end` | `PT_REGS_PARM1(ctx)` | `arg0`, `builtin variables` |
| **Philosophy** | "Safe" Rust wrappers | Raw C-to-Kernel mapping | High-level scripting |



### 1. The Attribute Macros (`#[xdp]`, `#[kprobe]`, etc.)

These are "hints" to the Aya compiler (specifically the `bpf-linker`).

* **ELF Sections:** 
    In eBPF, the kernel identifies programs based on the **ELF section name** they are stored in. When you 
    write `#[xdp]`, Aya automatically places that function into a section named `xdp`.
    
* **Standardized Entry Point:** 
    The macro also generates the necessary boilerplate to ensure the function matches the calling convention 
    required by the eBPF Virtual Machine (eVM).

### 2. The Context (`ctx`)

The "context" is the universal entry point: 

* **The "Window" to the Kernel:** 
    eBPF programs cannot access arbitrary kernel memory for security reasons. The `ctx` is the only "window" 
    the kernel provides you.
    
* **XdpContext:** As you noted, this specific context contains `data` (start of packet) and `data_end`. In 
  Rust/Aya, we use these to perform **bounds checks**, which the eBPF Verifier requires to prove we won't 
  crash the kernel.

### 3. Unified Flow: The "Context Pattern"

Every program type follows this pattern. This is a design choice by Aya to provide a consistent API. 
While the *data* inside the context changes, the *way* you access it remains the same.

| Program Type Macro | Context Type | What it represents |
| --- | --- | --- |
| `#[xdp]` | `XdpContext` | Raw network packet data (fastest path). |
| `#[classifier]` | `TcContext` | Network packets in the Traffic Control (TC) layer. |
| `#[kprobe]` | `ProbeContext` | CPU registers and arguments of a kernel function. |
| `#[tracepoint]` | `TracePointContext` | Static trace event data (defined in `/sys/kernel/debug/tracing`). |


### Why this "Default Flow" exists

The reason you see `try_function(ctx)` in almost every Aya example is to handle Rust's `Result` type.

eBPF programs must return a raw integer (like `XDP_PASS` which is 2). 
However, Rust developers prefer using `?` for error handling. 

Most Aya projects use this pattern:

1. **Outer Function:** Marked with `#[xdp]`, returns a `u32`.
2. **Inner Function:** Usually called `try_something`, returns a `Result`.
3. **The Result:** The outer function matches on the result; if it's an `Err`, it returns `XDP_ABORTED` 
   (safely dropping the packet).

## eBPF Program types handled with Aya:

Aya covers a vast range of eBPF program types more then the onces discussed above. As its designed to be a 
complete alternative to `libbpf`, it aims to support nearly every hook the Linux kernel offers.

Here are the other major program types supported by Aya, categorized by their use case:

### 1. Networking (Beyond XDP)

While XDP is the "fast path," these other types allow you to hook into different stages of the Linux network 
stack.

| Program Type Macro | Context Type | Representation / Use Case |
| --- | --- | --- |
| **`#[sk_msg]`** | `SkMsgContext` | Hooks into **Socket Maps**. Used to redirect data between sockets without passing through the full TCP/IP stack (great for service meshes). |
| **`#[sock_ops]`** | `SockOpsContext` | Triggers on **Socket Events** (connection established, timeout, etc.). Used to dynamically tune TCP parameters like window size. |
| **`#[socket_filter]`** | `SkBuffContext` | The original BPF hook. Allows filtering packets arriving at a specific socket (similar to how `tcpdump` works). |
| **`#[cgroup_skb]`** | `SkBuffContext` | Attaches to a **Control Group (cgroup)**. Used to enforce network policies (allow/deny) on all processes inside a specific container. |
| **`#[lwt_in]` / `#[lwt_out]**` | `LwtContext` | **Lightweight Tunneling**. Used for custom packet encapsulation/decapsulation logic. |

---

### 2. Specialized Observability & Tracing

These hooks allow you to look into user-space applications or hardware-level events.

| Program Type Macro | Context Type | Representation / Use Case |
| --- | --- | --- |
| **`#[uprobe]`** | `ProbeContext` | **User Probes**. Hooks into a function inside a user-space binary (e.g., tracking calls to `malloc` in a C app or `SSL_read` in OpenSSL). |
| **`#[uretprobe]`** | `ProbeContext` | Triggers when a user-space function **returns**. Used to capture return values (e.g., the result of a database query). |
| **`#[kretprobe]`** | `ProbeContext` | Triggers when a kernel function **returns**. |
| **`#[perf_event]`** | `PerfEventContext` | Hooks into **Hardware/Software Performance Counters**. Used for CPU profiling and "sampling" what the processor is doing. |
| **`#[raw_tracepoint]`** | `RawTracepointContext` | A lower-overhead version of tracepoints. It provides raw access to arguments without the kernel's pre-parsing. |

---

### 3. Security & Control

These are newer, highly powerful hooks used for system hardening.

| Program Type Macro | Context Type | Representation / Use Case |
| --- | --- | --- |
| **`#[lsm]`** | `LsmContext` | **Linux Security Module**. Allows you to implement custom security policies (e.g., "This specific process cannot open files in `/etc/`"). |
| **`#[cgroup_device]`** | `CgroupDeviceContext` | Controls access to **Device Files** (like `/dev/sda`) for processes within a specific cgroup. |

---

### The "Universal Pattern" in Aya

Regardless of the type, the Aya "Default Flow" you noticed remains consistent. For example, a **UProbe** 
looks almost identical to an **XDP** program in its structure:

```rust
// User-space function hook
#[uprobe]
pub fn track_malloc(ctx: ProbeContext) -> u32 {
    // 1. Get arguments from context
    // 2. Store in Map
    // 3. Return
    0 
}

```

Below on how to find the specific kernel arguments for a `Tracepoint` or `LSM` hook using `aya-tool`
-------------------------------------------------

## How to find what data is available in a Context `ctx`.

To find specific kernel arguments for your eBPF programs, you generally move from the "general documentation" 
into "system-specific reality."

Since every kernel version might have slightly different arguments, **aya-tool** and the Linux filesystem 
are your best friends.

Here is the step-by-step process to identify what data is available in your `Context`.

---

### Step 1: Identify the Hook Point

Before using `aya-tool`, you need to know exactly what you are looking for. 
For **Tracepoints**, these are listed in the kernel's debug file system.

* **Action:** Run `ls /sys/kernel/debug/tracing/events` to see categories (like `syscalls`, `net`, `sched`).
* **Action:** Look inside a category to find a specific event, e.g., `ls /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat`.

### Step 2: Read the Kernel Format File

The kernel actually tells you exactly what the "Context" looks like for that specific hook.

* **Action:** Run `cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format`.
* **Output:** You will see a list of fields like `common_type`, `dfd`, `filename`, and `flags`. 
  This is the "Raw" data your BPF program will receive.

### Step 3: Use `aya-tool` to Generate Rust Types

Manually defining Rust structs to match those kernel fields is error-prone because of memory alignment. 
`aya-tool` automates this by reading the kernel's **BTF (BPF Type Format)**.

* **Action:** Use the `aya-tool` to generate a "bindings" file.
```bash
aya-tool generate sk_buff > myapp-ebpf/src/bindings.rs

```

* **Result:** This creates a Rust-compatible struct that perfectly matches the kernel's memory layout for 
  that specific object.

### Step 4: Map Arguments in your Rust Code

Now that you know the fields, you use the `ctx` in your Aya program. 
For `TracePointContext`, you access arguments by their offset or by using the generated bindings.

```rust
#[tracepoint]
pub fn handle_openat(ctx: TracePointContext) -> u32 {
    // For a tracepoint, args are often accessed as offsets
    // or cast to the struct generated in Step 3.
    let filename_ptr: *const u8 = unsafe { ctx.read_at(16).unwrap() }; 
    0
}

```

### Step 5: Verify with `bpftrace` (The "Sanity Check")

Before writing complex Rust code, verify the arguments are what you expect using a one-liner.

* **Action:** `bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s\n", args->filename); }'`
* **Why:** If `bpftrace` sees the data, your Aya program will be able to see it too.

---

### Summary of the Discovery Flow

| Step | Tool | Purpose |
| --- | --- | --- |
| **1. Find** | `ls /sys/kernel/...` | Locate the specific hook name. |
| **2. Inspect** | `cat .../format` | See the raw data structure of the context. |
| **3. Bind** | `aya-tool` | Create safe Rust structs for that data. |
| **4. Implement** | `cargo xtask build` | Write the logic using the generated types. |



## Example: How to use `aya-tool` to generate bindings for a specific custom Kernel Struct:

To generate bindings for specific kernel structures, we use `aya-tool` alongside a small "stub" file. 
This is necessary because the kernel contains thousands of structs, and you usually only want a few for your 
specific program (like `task_struct` or `path`).

Here is the step-by-step workflow to get those structures into your Rust code.

---

### Step 1: Create a `vmlinux.h` (The Source)

Aya needs to see the kernel's definitions. On most modern Linux distributions, the kernel exports its own 
types via BTF.

* **Action:** Generate the master header file from your running kernel:
```bash
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h

```


*This file now contains every single struct your current kernel knows about.*

### Step 2: Create a Bindings "Input" File

You don't want to translate all 100,000+ lines of `vmlinux.h` into Rust. You create a small C file 
(e.g., `input.h`) that tells `aya-tool` exactly what you need.

* **Example `input.h`:**
```c
#include "vmlinux.h"

// We want to use these specifically in our Rust code
struct task_struct _unused1;
struct path _unused2;

```



### Step 3: Run `aya-tool`

Now, use `aya-tool` to perform the translation. It uses `bindgen` under the hood but is optimized for eBPF 
and `no_std` Rust.

* **Action:**
```bash
aya-tool generate --input-file input.h --output-file myapp-ebpf/src/bindings.rs

```

---

### Step 4: Use the Bindings in your Aya Program

Now your `bindings.rs` file contains clean Rust versions of those complex kernel structs. 
You can use them inside your program by casting the `ctx` data.

**Example: Reading the current process name (comm) from `task_struct`:**

```rust
use crate::bindings::task_struct;
use aya_ebpf::helpers::bpf_get_current_task;

#[kprobe]
pub fn monitor_task(ctx: ProbeContext) -> u32 {
    // 1. Get the pointer to the current task_struct in the kernel
    let task_ptr: *mut task_struct = unsafe { bpf_get_current_task() as *mut task_struct };

    // 2. Safely read the 'comm' field (process name) using bpf_probe_read_kernel
    // In Aya, we often use helpers or direct pointer access if the verifier allows
    let comm = unsafe { (*task_ptr).comm }; 
    
    0
}

```

---

### Why this is the "Gold Standard" for Aya Flow

1. **No Magic Numbers:** You aren't guessing that the process ID is at "offset 24." You are using `task.pid`.
2. **Compile-time Checks:** If the kernel changes a struct member name in a future version, your Rust code 
   will fail to compile rather than crashing at runtime.
3. **Memory Alignment:** `aya-tool` handles all the `#[repr(C)]` and padding requirements that the kernel expects.

---

### Summary Checklist for your Project

* [ ] **`bpftool`** installed (to extract `vmlinux.h`).
* [ ] **`aya-tool`** installed (`cargo install aya-tool`).
* [ ] **`input.h`** created with the structs you need.
* [ ] **`bindings.rs`** generated and included in your `lib.rs` or `main.rs`.


## Example handle "Pointer Chasing" (following a pointer from one struct to another) safely in Aya:

In the kernel, data is often nested. For example, if you want to find the **mount namespace ID** of a 
process, you have to go from `task_struct` → `nsproxy` → `mnt_ns`. This is called **Pointer Chasing**.

In standard C, you would just write `task->nsproxy->mnt_ns`. However, in eBPF, the verifier will reject this 
because it cannot guarantee those pointers are valid or that the memory won't be paged out.

---

### The Rules of the Road

1. **The Verifier is Watching:** You cannot simply "dereference" a pointer in the kernel unless the 
   verifier can prove it's safe (e.g., it came directly from a trusted context).
2. **The Helper Pattern:** For most pointers, you must use the `bpf_probe_read_kernel` helper function. 
   This is a "safe" copy mechanism that returns an error if the pointer is junk, rather than crashing the system.

---

### Step-by-Step: Safe Pointer Chasing in Aya

Using the bindings we generated in the previous step, here is how you safely "chase" a pointer from the 
current task to its parent process ID.

#### 1. Define the Helper

Aya provides these helpers in the `aya_ebpf::helpers` module. They are `unsafe` because they deal with raw 
memory.

#### 2. Perform the Read

You have to "pull" the data from kernel memory into a local variable on the eBPF stack.

```rust
use crate::bindings::{task_struct};
use aya_ebpf::helpers::{bpf_get_current_task, bpf_probe_read_kernel};

pub unsafe fn get_parent_pid() -> Result<i32, i64> {
    // 1. Get the initial pointer (the "root" of our chase)
    let task_ptr: *const task_struct = bpf_get_current_task() as *const task_struct;

    // 2. We want to read the 'real_parent' pointer located inside task_struct
    // We use bpf_probe_read_kernel to safely copy the pointer address itself
    let parent_task_ptr: *const task_struct = bpf_probe_read_kernel(&((*task_ptr).real_parent))?;

    // 3. Now that we have the parent's address, read the 'tgid' (Thread Group ID / PID)
    let parent_pid: i32 = bpf_probe_read_kernel(&((*parent_task_ptr).tgid))?;

    Ok(parent_pid)
}

```

---

### Why this is different from Userspace Rust

* **No `Box` or `Arc`:** You are dealing with raw kernel addresses.
* **Error Handling:** Every step of the chase can fail. 
  If a process is exiting, `real_parent` might be null. The `?` operator in Aya (when used in 
  a `try_` function) makes this easy to manage.
* **Stack Limits:** Remember that the eBPF stack is very small (512 bytes). 
  If you try to copy a massive struct instead of just a field, the compiler/verifier will complain.

### Summary of the Flow

| Action | Native C/Rust | eBPF (Aya) |
| --- | --- | --- |
| **Access Field** | `struct.field` | `struct.field` (Only if `struct` is on stack) |
| **Follow Pointer** | `ptr->field` | `bpf_probe_read_kernel(&ptr->field)` |
| **Root Access** | Variable name | `ctx` or `bpf_get_current_task()` |


## Example:  "chased" data back to userspace using a Perf Event Array or a Ring Buffer

When you've finished "chasing" a pointer and have the data you need (like a Process ID or a filename), you 
need to get it out of the kernel and into your userspace app.

In the eBPF world, you have two primary high-speed highways for this: **Perf Event Arrays** (older, 
compatible) and **Ring Buffers** (newer, more efficient).

---

## 1. Perf Event Array vs. Ring Buffer

Think of these as the "output" side of your eBPF flow.

| Feature | **Perf Event Array** | **Ring Buffer** (Recommended) |
| --- | --- | --- |
| **Kernel Version** | 4.15+ | 5.8+ |
| **Memory** | Per-CPU (Multiple buffers) | Shared (One big buffer) |
| **Ordering** | Events may arrive out of order. | Strict FIFO (First-In-First-Out). |
| **Efficiency** | High, but wastes memory on idle CPUs. | Very high, better memory utilization. |

---

## 2. Kernel-Side Implementation (The Producer)

First, you define the data structure you want to send and the Map itself.

### Defining the Event Struct

```rust
#[repr(C)]
#[derive(Clone, Copy)]
pub struct ProcessEvent {
    pub pid: u32,
    pub ppid: u32,
    pub comm: [u8; 16],
}

```

### Sending via Ring Buffer

Using the **Ring Buffer** is the modern Aya way. It uses a "reserve and submit" pattern to avoid 
unnecessary memory copies.

```rust
#[map]
static EVENTS: RingBuf = RingBuf::with_byte_size(256 * 1024, 0); // 256KB buffer

fn try_monitor(ctx: &ProbeContext) -> Result<u32, i64> {
    // 1. Reserve space in the buffer
    if let Some(mut event_slot) = EVENTS.reserve::<ProcessEvent>(0) {
        // 2. Write directly into the reserved memory
        unsafe {
            let data = event_slot.as_mut_ptr();
            (*data).pid = bpf_get_current_pid_tgid() as u32;
            // ... fill other fields ...
        }
        // 3. Commit the data to userspace
        event_slot.submit(0);
    }
    Ok(0)
}

```

---

## 3. Userspace Implementation (The Consumer)

On the userspace side, Aya provides an easy way to listen for these events using standard Rust iterators or 
async streams.

```rust
// 1. Open the Map
let mut events = RingBuf::try_from(bpf.map_mut("EVENTS")?)?;

// 2. Poll for new data (using Tokio for async)
let mut poll = AsyncFd::new(events)?;
loop {
    let mut guard = poll.readable_mut().await?;
    let ring_buf = guard.get_inner_mut();
    
    // 3. Process all available events
    while let Some(event_binary) = ring_buf.next() {
        let event = unsafe { ptr::read(event_binary.as_ptr() as *const ProcessEvent) };
        println!("New Process: PID {} (Parent {})", event.pid, event.ppid);
    }
    guard.clear_ready();
}

```

---

## Summary of the Full Aya Flow

Now you've seen the entire loop:

1. **Trigger:** A kernel event (like a KProbe) fires.
2. **Context:** The kernel hands your program a `ctx`.
3. **Discovery:** You use `aya-tool` to know where fields are.
4. **Chase:** You use `bpf_probe_read_kernel` to follow pointers safely.
5. **Output:** You `reserve` and `submit` the data to a `RingBuf`.
6. **Consume:** Your userspace app prints the data to the screen.

